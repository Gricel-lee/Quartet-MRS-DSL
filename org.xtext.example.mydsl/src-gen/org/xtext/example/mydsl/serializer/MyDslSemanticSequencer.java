/*
 * generated by Xtext 2.28.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Accrue;
import org.xtext.example.mydsl.myDsl.ActionEnd;
import org.xtext.example.mydsl.myDsl.AtMost;
import org.xtext.example.mydsl.myDsl.Avoid;
import org.xtext.example.mydsl.myDsl.ComplexMissions;
import org.xtext.example.mydsl.myDsl.Composition;
import org.xtext.example.mydsl.myDsl.Conservation;
import org.xtext.example.mydsl.myDsl.Counteract;
import org.xtext.example.mydsl.myDsl.Delayed;
import org.xtext.example.mydsl.myDsl.End;
import org.xtext.example.mydsl.myDsl.Equidistance;
import org.xtext.example.mydsl.myDsl.Event;
import org.xtext.example.mydsl.myDsl.Execute;
import org.xtext.example.mydsl.myDsl.Location;
import org.xtext.example.mydsl.myDsl.LocationEvent;
import org.xtext.example.mydsl.myDsl.Maximize;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Negation;
import org.xtext.example.mydsl.myDsl.Patrol;
import org.xtext.example.mydsl.myDsl.Pause;
import org.xtext.example.mydsl.myDsl.Preservation;
import org.xtext.example.mydsl.myDsl.ProblemSpecifications;
import org.xtext.example.mydsl.myDsl.Proportional;
import org.xtext.example.mydsl.myDsl.React;
import org.xtext.example.mydsl.myDsl.ReliabilityConfidence;
import org.xtext.example.mydsl.myDsl.Repeat;
import org.xtext.example.mydsl.myDsl.Robots;
import org.xtext.example.mydsl.myDsl.ShallMissions;
import org.xtext.example.mydsl.myDsl.Timeout;
import org.xtext.example.mydsl.myDsl.TopMissions;
import org.xtext.example.mydsl.myDsl.Trail;
import org.xtext.example.mydsl.myDsl.Visit1;
import org.xtext.example.mydsl.myDsl.Visit2;
import org.xtext.example.mydsl.myDsl.Wait;
import org.xtext.example.mydsl.myDsl.Within;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ACCRUE:
				sequence_Accrue(context, (Accrue) semanticObject); 
				return; 
			case MyDslPackage.ACTION:
				sequence_Action(context, (org.xtext.example.mydsl.myDsl.Action) semanticObject); 
				return; 
			case MyDslPackage.ACTION_END:
				sequence_ActionEnd(context, (ActionEnd) semanticObject); 
				return; 
			case MyDslPackage.AT_MOST:
				sequence_AtMost(context, (AtMost) semanticObject); 
				return; 
			case MyDslPackage.AVOID:
				sequence_Avoid(context, (Avoid) semanticObject); 
				return; 
			case MyDslPackage.COMPLEX_MISSIONS:
				sequence_ComplexMissions(context, (ComplexMissions) semanticObject); 
				return; 
			case MyDslPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case MyDslPackage.CONSERVATION:
				sequence_Conservation(context, (Conservation) semanticObject); 
				return; 
			case MyDslPackage.COUNTERACT:
				sequence_Counteract(context, (Counteract) semanticObject); 
				return; 
			case MyDslPackage.DELAYED:
				sequence_Delayed(context, (Delayed) semanticObject); 
				return; 
			case MyDslPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case MyDslPackage.EQUIDISTANCE:
				sequence_Equidistance(context, (Equidistance) semanticObject); 
				return; 
			case MyDslPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case MyDslPackage.EXECUTE:
				sequence_Execute(context, (Execute) semanticObject); 
				return; 
			case MyDslPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case MyDslPackage.LOCATION_EVENT:
				sequence_LocationEvent(context, (LocationEvent) semanticObject); 
				return; 
			case MyDslPackage.MAXIMIZE:
				sequence_Maximize(context, (Maximize) semanticObject); 
				return; 
			case MyDslPackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case MyDslPackage.PATROL:
				sequence_Patrol(context, (Patrol) semanticObject); 
				return; 
			case MyDslPackage.PAUSE:
				sequence_Pause(context, (Pause) semanticObject); 
				return; 
			case MyDslPackage.PRESERVATION:
				sequence_Preservation(context, (Preservation) semanticObject); 
				return; 
			case MyDslPackage.PROBLEM_SPECIFICATIONS:
				sequence_ProblemSpecifications(context, (ProblemSpecifications) semanticObject); 
				return; 
			case MyDslPackage.PROPORTIONAL:
				sequence_Proportional(context, (Proportional) semanticObject); 
				return; 
			case MyDslPackage.REACT:
				sequence_React(context, (React) semanticObject); 
				return; 
			case MyDslPackage.RELIABILITY_CONFIDENCE:
				sequence_ReliabilityConfidence(context, (ReliabilityConfidence) semanticObject); 
				return; 
			case MyDslPackage.REPEAT:
				sequence_Repeat(context, (Repeat) semanticObject); 
				return; 
			case MyDslPackage.ROBOTS:
				sequence_Robots(context, (Robots) semanticObject); 
				return; 
			case MyDslPackage.SHALL_MISSIONS:
				sequence_ShallMissions(context, (ShallMissions) semanticObject); 
				return; 
			case MyDslPackage.TIMEOUT:
				sequence_Timeout(context, (Timeout) semanticObject); 
				return; 
			case MyDslPackage.TOP_MISSIONS:
				sequence_TopMissions(context, (TopMissions) semanticObject); 
				return; 
			case MyDslPackage.TRAIL:
				sequence_Trail(context, (Trail) semanticObject); 
				return; 
			case MyDslPackage.VISIT1:
				sequence_Visit1(context, (Visit1) semanticObject); 
				return; 
			case MyDslPackage.VISIT2:
				sequence_Visit2(context, (Visit2) semanticObject); 
				return; 
			case MyDslPackage.WAIT:
				sequence_Wait(context, (Wait) semanticObject); 
				return; 
			case MyDslPackage.WITHIN:
				sequence_Within(context, (Within) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Accrue
	 *     CompositePatterns returns Accrue
	 *     Accrue returns Accrue
	 *
	 * Constraint:
	 *     (robots=[Robots|EString] measure=EString missions=Missions)
	 * </pre>
	 */
	protected void sequence_Accrue(ISerializationContext context, Accrue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACCRUE__ROBOTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACCRUE__ROBOTS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACCRUE__MEASURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACCRUE__MEASURE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACCRUE__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACCRUE__MISSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccrueAccess().getRobotsRobotsEStringParserRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.ACCRUE__ROBOTS, false));
		feeder.accept(grammarAccess.getAccrueAccess().getMeasureEStringParserRuleCall_3_0(), semanticObject.getMeasure());
		feeder.accept(grammarAccess.getAccrueAccess().getMissionsMissionsParserRuleCall_5_0(), semanticObject.getMissions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns ActionEnd
	 *     ActionEnd returns ActionEnd
	 *
	 * Constraint:
	 *     (name=EString action=[Action|EString] description=EString?)
	 * </pre>
	 */
	protected void sequence_ActionEnd(ISerializationContext context, ActionEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, org.xtext.example.mydsl.myDsl.Action semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns AtMost
	 *     ElementaryPatterns returns AtMost
	 *     AtMost returns AtMost
	 *
	 * Constraint:
	 *     (
	 *         reward='reward'? 
	 *         measure=EString 
	 *         (type='at most' | type='less than' | type='at least' | type='greater than' | type='exactly') 
	 *         value=EInt 
	 *         mission=Missions
	 *     )
	 * </pre>
	 */
	protected void sequence_AtMost(ISerializationContext context, AtMost semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns Avoid
	 *     AvoidanceVisit returns Avoid
	 *     Avoid returns Avoid
	 *
	 * Constraint:
	 *     (locations+=[Location|EString] locations+=[Location|EString]* (type='until' | type='after')? condition=[Condition|EString]?)
	 * </pre>
	 */
	protected void sequence_Avoid(ISerializationContext context, Avoid semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns ComplexMissions
	 *     ComplexMissions returns ComplexMissions
	 *
	 * Constraint:
	 *     composition=MissionOperation
	 * </pre>
	 */
	protected void sequence_ComplexMissions(ISerializationContext context, ComplexMissions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPLEX_MISSIONS__COMPOSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPLEX_MISSIONS__COMPOSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexMissionsAccess().getCompositionMissionOperationParserRuleCall_1_0(), semanticObject.getComposition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MissionOperation returns Composition
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (miss1=Missions (binaryType='and' | binaryType='or') miss2=Missions)
	 * </pre>
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Conservation
	 *     CompositePatterns returns Conservation
	 *     Conservation returns Conservation
	 *
	 * Constraint:
	 *     (measure=EString missions=Missions)
	 * </pre>
	 */
	protected void sequence_Conservation(ISerializationContext context, Conservation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSERVATION__MEASURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSERVATION__MEASURE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSERVATION__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSERVATION__MISSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConservationAccess().getMeasureEStringParserRuleCall_2_0(), semanticObject.getMeasure());
		feeder.accept(grammarAccess.getConservationAccess().getMissionsMissionsParserRuleCall_4_0(), semanticObject.getMissions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns Counteract
	 *     Counteract returns Counteract
	 *
	 * Constraint:
	 *     ((type='instantly' | type='with a delay') locations=[Location|EString] condition=[Condition|EString])
	 * </pre>
	 */
	protected void sequence_Counteract(ISerializationContext context, Counteract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Delayed returns Delayed
	 *
	 * Constraint:
	 *     (condition=[Condition|EString] (action=[Action|EString] | pattern=SpecificationPatterns | locations+=[Location|EString]))
	 * </pre>
	 */
	protected void sequence_Delayed(ISerializationContext context, Delayed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns End
	 *     CompositePatterns returns End
	 *     End returns End
	 *
	 * Constraint:
	 *     (missions=Missions value=EInt)
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.END__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.END__MISSIONS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.END__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.END__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndAccess().getMissionsMissionsParserRuleCall_2_0(), semanticObject.getMissions());
		feeder.accept(grammarAccess.getEndAccess().getValueEIntParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Equidistance
	 *     CompositePatterns returns Equidistance
	 *     Equidistance returns Equidistance
	 *
	 * Constraint:
	 *     (robots=[Robots|EString] missions=Missions robots1=[Robots|EString] robots2=[Robots|EString])
	 * </pre>
	 */
	protected void sequence_Equidistance(ISerializationContext context, Equidistance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__ROBOTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__ROBOTS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__MISSIONS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__ROBOTS1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__ROBOTS1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__ROBOTS2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EQUIDISTANCE__ROBOTS2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquidistanceAccess().getRobotsRobotsEStringParserRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.EQUIDISTANCE__ROBOTS, false));
		feeder.accept(grammarAccess.getEquidistanceAccess().getMissionsMissionsParserRuleCall_2_0(), semanticObject.getMissions());
		feeder.accept(grammarAccess.getEquidistanceAccess().getRobots1RobotsEStringParserRuleCall_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.EQUIDISTANCE__ROBOTS1, false));
		feeder.accept(grammarAccess.getEquidistanceAccess().getRobots2RobotsEStringParserRuleCall_5_0_1(), semanticObject.eGet(MyDslPackage.Literals.EQUIDISTANCE__ROBOTS2, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Event
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=EString condition=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Execute
	 *     CompositePatterns returns Execute
	 *     Execute returns Execute
	 *
	 * Constraint:
	 *     (robots=[Robots|EString] setOfActions+=[Action|EString] setOfActions+=[Action|EString]*)
	 * </pre>
	 */
	protected void sequence_Execute(ISerializationContext context, Execute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns LocationEvent
	 *     LocationEvent returns LocationEvent
	 *
	 * Constraint:
	 *     (name=EString robots=[Robots|EString] location=[Location|EString] description=EString?)
	 * </pre>
	 */
	protected void sequence_LocationEvent(ISerializationContext context, LocationEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Location returns Location
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOCATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOCATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Maximize
	 *     ElementaryPatterns returns Maximize
	 *     Maximize returns Maximize
	 *
	 * Constraint:
	 *     (reward='reward'? (type='maximize' | type='minimize') measure=EString mission=Missions)
	 * </pre>
	 */
	protected void sequence_Maximize(ISerializationContext context, Maximize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MissionOperation returns Negation
	 *     Negation returns Negation
	 *
	 * Constraint:
	 *     not=Missions
	 * </pre>
	 */
	protected void sequence_Negation(ISerializationContext context, Negation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NEGATION__NOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NEGATION__NOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationAccess().getNotMissionsParserRuleCall_3_0(), semanticObject.getNot());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns Patrol
	 *     Patrol returns Patrol
	 *
	 * Constraint:
	 *     ((type='in sequence' | type='in order' | type='in strict order' | type='fairly')? locations+=[Location|EString] locations+=[Location|EString]*)
	 * </pre>
	 */
	protected void sequence_Patrol(ISerializationContext context, Patrol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Pause
	 *     CompositePatterns returns Pause
	 *     Pause returns Pause
	 *
	 * Constraint:
	 *     (value=EInt missions=Missions)
	 * </pre>
	 */
	protected void sequence_Pause(ISerializationContext context, Pause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PAUSE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PAUSE__VALUE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PAUSE__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PAUSE__MISSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPauseAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getPauseAccess().getMissionsMissionsParserRuleCall_3_0(), semanticObject.getMissions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Preservation
	 *     CompositePatterns returns Preservation
	 *     Preservation returns Preservation
	 *
	 * Constraint:
	 *     (measure=EString value1=EInt value2=EInt missions=Missions)
	 * </pre>
	 */
	protected void sequence_Preservation(ISerializationContext context, Preservation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRESERVATION__MEASURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRESERVATION__MEASURE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRESERVATION__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRESERVATION__VALUE1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRESERVATION__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRESERVATION__VALUE2));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRESERVATION__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRESERVATION__MISSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreservationAccess().getMeasureEStringParserRuleCall_2_0(), semanticObject.getMeasure());
		feeder.accept(grammarAccess.getPreservationAccess().getValue1EIntParserRuleCall_5_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getPreservationAccess().getValue2EIntParserRuleCall_7_0(), semanticObject.getValue2());
		feeder.accept(grammarAccess.getPreservationAccess().getMissionsMissionsParserRuleCall_10_0(), semanticObject.getMissions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProblemSpecifications returns ProblemSpecifications
	 *
	 * Constraint:
	 *     (
	 *         (location+=Location location+=Location*)? 
	 *         (action+=Action action+=Action*)? 
	 *         (robots+=Robots robots+=Robots*)? 
	 *         (condition+=Condition condition+=Condition*)? 
	 *         (topmissions+=TopMissions topmissions+=TopMissions*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ProblemSpecifications(ISerializationContext context, ProblemSpecifications semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Proportional
	 *     CompositePatterns returns Proportional
	 *     Proportional returns Proportional
	 *
	 * Constraint:
	 *     (mission1=Missions mission2=Missions value=EInt)
	 * </pre>
	 */
	protected void sequence_Proportional(ISerializationContext context, Proportional semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPORTIONAL__MISSION1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPORTIONAL__MISSION1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPORTIONAL__MISSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPORTIONAL__MISSION2));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PROPORTIONAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PROPORTIONAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProportionalAccess().getMission1MissionsParserRuleCall_3_0(), semanticObject.getMission1());
		feeder.accept(grammarAccess.getProportionalAccess().getMission2MissionsParserRuleCall_5_0(), semanticObject.getMission2());
		feeder.accept(grammarAccess.getProportionalAccess().getValueEIntParserRuleCall_8_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns React
	 *     React returns React
	 *
	 * Constraint:
	 *     (
	 *         (type='instantly' | type='with a delay' | type='promptly') 
	 *         condition=[Condition|EString] 
	 *         (action=[Action|EString] | pattern=SpecificationPatterns | locations+=[Location|EString])
	 *     )
	 * </pre>
	 */
	protected void sequence_React(ISerializationContext context, React semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns ReliabilityConfidence
	 *     CompositePatterns returns ReliabilityConfidence
	 *     ReliabilityConfidence returns ReliabilityConfidence
	 *
	 * Constraint:
	 *     (missions=Missions (type1='with confidence' | type1='with reliability') measure=EString (type2='greater than' | type2='less than') value=EInt)
	 * </pre>
	 */
	protected void sequence_ReliabilityConfidence(ISerializationContext context, ReliabilityConfidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Repeat
	 *     CompositePatterns returns Repeat
	 *     Repeat returns Repeat
	 *
	 * Constraint:
	 *     (missions=Missions value=EInt)
	 * </pre>
	 */
	protected void sequence_Repeat(ISerializationContext context, Repeat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REPEAT__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REPEAT__MISSIONS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REPEAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REPEAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatAccess().getMissionsMissionsParserRuleCall_2_0(), semanticObject.getMissions());
		feeder.accept(grammarAccess.getRepeatAccess().getValueEIntParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Robots returns Robots
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Robots(ISerializationContext context, Robots semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ROBOTS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ROBOTS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRobotsAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns ShallMissions
	 *     ShallMissions returns ShallMissions
	 *
	 * Constraint:
	 *     (robots=[Robots|EString] movementPatterns=SpecificationPatterns)
	 * </pre>
	 */
	protected void sequence_ShallMissions(ISerializationContext context, ShallMissions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHALL_MISSIONS__ROBOTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHALL_MISSIONS__ROBOTS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHALL_MISSIONS__MOVEMENT_PATTERNS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHALL_MISSIONS__MOVEMENT_PATTERNS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShallMissionsAccess().getRobotsRobotsEStringParserRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.SHALL_MISSIONS__ROBOTS, false));
		feeder.accept(grammarAccess.getShallMissionsAccess().getMovementPatternsSpecificationPatternsParserRuleCall_3_0(), semanticObject.getMovementPatterns());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Timeout
	 *     CompositePatterns returns Timeout
	 *     Timeout returns Timeout
	 *
	 * Constraint:
	 *     (value=EInt missions=Missions)
	 * </pre>
	 */
	protected void sequence_Timeout(ISerializationContext context, Timeout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TIMEOUT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TIMEOUT__VALUE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TIMEOUT__MISSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TIMEOUT__MISSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeoutAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeoutAccess().getMissionsMissionsParserRuleCall_3_0(), semanticObject.getMissions());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TopMissions returns TopMissions
	 *
	 * Constraint:
	 *     (name=EString mission=Missions)
	 * </pre>
	 */
	protected void sequence_TopMissions(ISerializationContext context, TopMissions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TOP_MISSIONS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TOP_MISSIONS__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TOP_MISSIONS__MISSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TOP_MISSIONS__MISSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopMissionsAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTopMissionsAccess().getMissionMissionsParserRuleCall_2_0(), semanticObject.getMission());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Trail
	 *     CompositePatterns returns Trail
	 *     Trail returns Trail
	 *
	 * Constraint:
	 *     (robots=[Robots|EString] objetToFollow=EString value=EInt)
	 * </pre>
	 */
	protected void sequence_Trail(ISerializationContext context, Trail semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRAIL__ROBOTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRAIL__ROBOTS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRAIL__OBJET_TO_FOLLOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRAIL__OBJET_TO_FOLLOW));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRAIL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRAIL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrailAccess().getRobotsRobotsEStringParserRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.TRAIL__ROBOTS, false));
		feeder.accept(grammarAccess.getTrailAccess().getObjetToFollowEStringParserRuleCall_3_0(), semanticObject.getObjetToFollow());
		feeder.accept(grammarAccess.getTrailAccess().getValueEIntParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns Visit1
	 *     Visit1 returns Visit1
	 *
	 * Constraint:
	 *     ((type='in sequence' | type='in order' | type='in strict order' | type='fairly')? locations+=[Location|EString] locations+=[Location|EString]*)
	 * </pre>
	 */
	protected void sequence_Visit1(ISerializationContext context, Visit1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns Visit2
	 *     AvoidanceVisit returns Visit2
	 *     Visit2 returns Visit2
	 *
	 * Constraint:
	 *     ((type='more than' | type='less than' | type='exactly') number=EInt locations+=[Location|EString] locations+=[Location|EString]*)
	 * </pre>
	 */
	protected void sequence_Visit2(ISerializationContext context, Visit2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpecificationPatterns returns Wait
	 *     Wait returns Wait
	 *
	 * Constraint:
	 *     (locations+=[Location|EString] condition=[Condition|EString])
	 * </pre>
	 */
	protected void sequence_Wait(ISerializationContext context, Wait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Missions returns Within
	 *     ElementaryPatterns returns Within
	 *     Within returns Within
	 *
	 * Constraint:
	 *     (
	 *         reward='reward'? 
	 *         measure=EString 
	 *         (type='within' | type='strictly within') 
	 *         value1=EInt 
	 *         value2=EInt 
	 *         mission=Missions
	 *     )
	 * </pre>
	 */
	protected void sequence_Within(ISerializationContext context, Within semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
