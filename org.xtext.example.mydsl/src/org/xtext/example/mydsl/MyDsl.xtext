// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

//import "http://www.example.org/patterns" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore



ProblemSpecifications returns ProblemSpecifications:
	{ProblemSpecifications}
	'problem' 'specifications'
	'{'
		('locations:' location+=Location ( "," location+=Location)* )?
		('actions:' action+=Action ( "," action+=Action)* )?
		('robots:' robots+=Robots ( "," robots+=Robots)* )?
		('conditions:' condition+=Condition (  condition+=Condition)* )?
		('missions:'  topmissions+=TopMissions ( ";" topmissions+=TopMissions)* )?
		//('movement' 'patterns:'  specificationPatterns+=SpecificationPatterns ( "," specificationPatterns+=SpecificationPatterns)* )?
		//('elementary' 'patterns:' '{' elementaryPatterns+=ElementaryPatterns ( "," elementaryPatterns+=ElementaryPatterns)* '}' )?
		//('composite' 'patterns:' '{' compositePatterns+=CompositePatterns ( "," compositePatterns+=CompositePatterns)* '}' )?
	'}';

Condition returns Condition:
	 Event | ActionEnd | LocationEvent;
	
Event returns Event:
	{Event}
	name=EString ':'
	condition=EString 'is' 'true' ('('description=EString ')')?;

ActionEnd returns ActionEnd:
	{ActionEnd}
	name=EString ':'
	action=[Action|EString] 'is' 'ended' ('('description=EString ')')?;

LocationEvent returns LocationEvent:
	{LocationEvent}
	name=EString ':'
	robots=[Robots|EString] 'at loc' location=[Location|EString]  ('('description=EString ')')?;

Location returns Location:
	{Location}
	name=EString;

Action returns Action:
	{Action}
	name=EString;

Robots returns Robots:
	{Robots}
	name=EString;

EString returns ecore::EString:
	STRING | ID;


	
	
/* Missions and mission composition */

				
TopMissions returns TopMissions:
	name=EString  ':'
	mission=Missions
;
Missions returns Missions:
	ShallMissions | ComplexMissions | ElementaryPatterns | CompositePatterns;


//Missions that do not contain any probabilities or rewards
//This avoids nested probabilistic and reward operators
Mission_no_prob_rew returns Missions:
	ShallMissions | 
	ComplexMissions | 
	//CompositePatterns
	Pause |
	Timeout |
	Repeat |
	End |
	Execute
;


MissionOperation returns MissionOperation:
	Negation | Composition;


ShallMissions returns ShallMissions:
	{ShallMissions}
	
	robots=[Robots|EString] 'shall'
		movementPatterns=SpecificationPatterns//--add in the future ( "," movementPatterns+=SpecificationPatterns)*
	;

ComplexMissions returns ComplexMissions:
	{ComplexMissions}
	//'complex' 'mission'
	composition=MissionOperation//--should work without this ( "," composition+=MissionOperation)* 
	;
	
Negation returns Negation:
	{Negation}
	'not' '(' not=Missions ')';

Composition returns Composition:
	{Composition}
	'(' miss1=Missions ')' binaryType=('and'|'or') '(' miss2=Missions ')';// ( binaryType=CompositionOperator missions+=Missions )* ;
	// cannot add more "binaryType" as it is only returned/written once (the last one to appear)


/* Specification patterns */
	
SpecificationPatterns returns SpecificationPatterns:
	Visit1 | Patrol | AvoidanceVisit |React | Counteract | Wait;

//Coverage and Patrol
Visit1 returns Visit1: //this was changed to add 'visit loc' (without any string in the middle)
	{Visit1}
	'visit' type=('in sequence' | 'in order' | 'in strict order' | 'fairly')?  locations+=[Location|EString] ("," locations+=[Location|EString])* ;

Patrol returns Patrol:
	{Patrol}
	'patrol' type=('in sequence' | 'in order' | 'in strict order' | 'fairly')?  locations+=[Location|EString] ("," locations+=[Location|EString])* ;

	
//Avoidance
AvoidanceVisit returns AvoidanceVisit:
	Visit2 | Avoid;

Visit2 returns Visit2:
	{Visit2}
	'visit' type =('more than' | 'less than' | 'exactly') number=EInt 'times' locations+=[Location|EString] ;

Avoid returns Avoid:
	{Avoid}
	'avoid' locations+=[Location|EString] ("," locations+=[Location|EString])*  type=('until'|'after')? (condition=[Condition|EString])?
	;
	
React returns React:
	{React}
	'react'	
	type = ('instantly'|'with a delay'| 'promptly')
	'to' condition=[Condition|EString] 'by'
	('exec' action=[Action|EString] | pattern=SpecificationPatterns | 'reach' locations+=[Location|EString]);

Counteract returns Counteract:
	{Counteract}
	'counteract' 
	type = ('instantly'|'with a delay') 'when' 'reach' locations=[Location|EString]
	'by' (condition=[Condition|EString])
	;

	
Wait returns Wait:
	{Wait}
	'wait in' locations+=[Location|EString] 
	'until' condition=[Condition|EString];


Delayed returns Delayed:
	{Delayed}
	'with' 'a' 'delay' 'to' 'condition' (condition=[Condition|EString]) 'by'
	('executing' (action=[Action|EString] | pattern=SpecificationPatterns) | 'reaching' locations+=[Location|EString]);





				
/* Elementary (quantitative) patterns */

ElementaryPatterns returns ElementaryPatterns:
	Maximize | AtMost | Within;

Maximize returns Maximize:
	{Maximize}
	reward = ('reward')?
	//Mission cannot be elementary patterns to avoid nested prob. or rewards.
	type=('maximize'|'minimize') measure=EString mission= Mission_no_prob_rew;
AtMost returns AtMost:
	{AtMost}
	reward = ('reward')?
	measure=EString type=('at most'|'less than'|'at least'|'greater than'| 'exactly') value=EDouble mission=Mission_no_prob_rew;
	
Within returns Within:
	{Within}
	reward = ('reward')?
	measure=EString type=('within'|'strictly within') value1=EDouble 'and' value2=EDouble mission=Mission_no_prob_rew;



/* Composite patterns */

CompositePatterns returns CompositePatterns:
	Conservation | Preservation | Pause | Timeout| Repeat
	| End | Proportional | Execute | Accrue | ReliabilityConfidence | Equidistance
	 | Trail  ;


Conservation returns Conservation:
	{Conservation}
	'conserve' measure=EString 'while' missions=Mission_no_prob_rew;

Preservation returns Preservation:
	{Preservation}
	'preserve' measure=EString 'within' '[' value1=EDouble ',' value2=EDouble ']' 'while' missions=Mission_no_prob_rew;

Pause returns Pause:
	{Pause}
	'pause' value=EInt missions=Missions;
	
Timeout returns Timeout:
	{Timeout}
	'timeout' value=EInt missions=Missions;	
	
Repeat returns Repeat:
	{Repeat}
	'repeat' missions=Missions 'every'  value=EInt;

End returns End:
	{End}
	'end' missions=Missions 'exactly_at' value=EInt; //***delete all except missions and add t
	//NOTE: I use exactly at instead of exactly_at as the paper
	//***'abort' missions=Missions 'if' (condition=[Condition|EString]| locationevent+=LocationEvent); // added + in "locationevent+=LocationEvent" to delete error

Proportional returns Proportional:
	{Proportional}
	'time' 'of' mission1=Missions 'proportional to' mission2=Missions 'by' 'factor' value=EInt //---NOTE: MAKE ALL INT OR FLOAT***
	;
	
Execute returns Execute:
	{Execute}
	'execute' robots=[Robots|EString] 'actions' setOfActions+=[Action|EString] ( "," setOfActions+=[Action|EString])*;

Accrue returns Accrue:
	{Accrue}
	robots=[Robots|EString] 'accrue' measure=EString 'while' missions=Missions;

ReliabilityConfidence returns ReliabilityConfidence:
	{ReliabilityConfidence}
	'achieve' missions=Mission_no_prob_rew type1=('with confidence'|'with reliability') measure=EString type2=('greater than'|'less than') value=EDouble ;
	
Equidistance returns Equidistance:
	{Equidistance}
	//'keep' 'distance' distance=EInt
	robots=[Robots|EString] missions=Missions 'equidistance' robots1=[Robots|EString]  robots2=[Robots|EString]
	;	
	//***add all robots

Trail returns Trail:
	{Trail}
	robots=[Robots|EString] 'trail' objetToFollow=EString  'with distance' value=EInt;




	
	
/* Others */
EDouble returns ecore::EDouble: 
	INT  '.' INT
;
	
EInt returns ecore::EInt:
	'-'? INT;

EFloat returns ecore::EFloat:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;