/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import org.xtext.example.mydsl.myDsl.ProblemSpecifications
import org.xtext.example.mydsl.myDsl.ShallMissions
import org.xtext.example.mydsl.myDsl.ComplexMissions
import org.xtext.example.mydsl.myDsl.ElementaryPatterns
import org.xtext.example.mydsl.myDsl.CompositePatterns
import org.xtext.example.mydsl.myDsl.Missions
import org.xtext.example.mydsl.myDsl.TopMissions
import org.xtext.example.mydsl.myDsl.Negation
import org.xtext.example.mydsl.myDsl.Composition
import org.xtext.example.mydsl.myDsl.Maximize
import org.xtext.example.mydsl.myDsl.AtMost
import org.xtext.example.mydsl.myDsl.Within
import org.xtext.example.mydsl.myDsl.Conservation
import org.xtext.example.mydsl.myDsl.Preservation
import org.xtext.example.mydsl.myDsl.Pause
import org.xtext.example.mydsl.myDsl.Timeout
import org.xtext.example.mydsl.myDsl.Repeat
import org.xtext.example.mydsl.myDsl.End
import org.xtext.example.mydsl.myDsl.Proportional
import org.xtext.example.mydsl.myDsl.Execute
import org.xtext.example.mydsl.myDsl.Accrue
import org.xtext.example.mydsl.myDsl.ReliabilityConfidence
import org.xtext.example.mydsl.myDsl.Equidistance
import org.xtext.example.mydsl.myDsl.Trail

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 * 
 * Constraints:
 * (a) prohibit nested probabilities, (b) accept only LTL
 * properties for the reward and probability operators, and 
 * (c) prohibit the definition of specifications that lead to
 * the conjunction of quantitative and non-quantitative PRISM
 * formulae since such formulae can not be processed by PRISM.
 */

class MyDslGenerator extends AbstractGenerator {
	
	// open root "problemSpecification" resource as a EObject - EObjects are automatically updated
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		// -- instance tree
		val root = resource?.allContents?.head as ProblemSpecifications;
		// -- top missions
		val topmissions = root.topmissions
		// -- type of mission
		var finalString = ""
		for (tm: topmissions.toList){
			finalString += org.xtext.example.mydsl.generator.MyDslGenerator.getTopMissionTranslated(tm, resource) //check each mission in topmissions
		}
		// --save file
		fsa.generateFile(resource.getURI().lastSegment + '.pm', finalString);
		
	}
		
	
	
	def static String getMissionTranslated(Missions miss, Resource resource){
		var s = new String // return string
		switch miss {
			//--- *Shall missions
			ShallMissions:{	
				// robot SHALL pat
				var rob = miss.robots.name //robot
				var pat = miss.movementPatterns //pattern
				var patt =  ResourcePattern.getPat(pat, rob, resource)  //specification pattern translation
				s += patt
				
				
				//*Continue with getting patterns
			}
			//--- *Complex (and,or,not) missions
			ComplexMissions:{
				//complex mission: NOT, AND, OR
				var typeComplexMiss = miss.composition
				switch typeComplexMiss{
					Negation:{
						var miss_negated = typeComplexMiss.not 
						s += "!("
						s += getMissionTranslated(miss_negated, resource) // get mission translated
						s+=")"
					}
					Composition:{
						var miss1 = typeComplexMiss.miss1
						var miss2 = typeComplexMiss.miss2
						s+= "("
						s += getMissionTranslated(miss1, resource) // get mission translated
						
						if (typeComplexMiss.binaryType=="and"){
							s += ") & ("	
						}
						else if (typeComplexMiss.binaryType=="or"){
							s += ") | ("
						}
						s += getMissionTranslated(miss2, resource) // get mission translated
						s+= " )"
					}
				}
				
			}
			//-- *Elementary (Maximize | AtMost | Within) missions
			ElementaryPatterns:{
				var m = miss
				var submission = m.mission
				// if probability -- done
				if (m.reward===null){
					switch m{
						//-- done
						Maximize:{
							if (m.type=="maximize"){
								s += "Pmax=?["+ getMissionTranslated(submission, resource) +"]"
							}
							else if (m.type=="minimize"){
								s += "Pmin=?["+ getMissionTranslated(submission, resource) +"]"
							}
							
						}
						//-- done
						AtMost:{
							var sign = ""
							if (m.type=="at most"){
								sign = "<="
								
							}
							else if (m.type=="less than"){
								sign = "<"
								
							}
							else if (m.type=="at least"){
								sign = ">="
								
							}
							else if (m.type=="greater than"){
								sign = ">"
								
							}
							else if (m.type=="exactly"){
								sign = "="
								}
							
							if (m.type=="exactly"){
								sign = ">="
								s += "(P"+ sign + m.value.toString +"["+ getMissionTranslated(submission, resource) +"]"
								s += ") & ("
								sign = "<="
								s += "P"+ sign + m.value.toString +"["+ getMissionTranslated(submission, resource) +"])"
							}
							else{
								s += "P"+ sign + m.value.toString +"["+ getMissionTranslated(submission, resource) +"]"
							}
							
						}
						//-- done
						Within:{
							if (m.type=="within"){
								s += "(P>="+ m.value1.toString +"["+ getMissionTranslated(submission, resource) +"])"
								s += " & "
								s += "(P<="+ m.value2.toString +"["+ getMissionTranslated(submission, resource) +"])"
							}
							else if (m.type=="strictly within"){
								s += "(P>"+ m.value1.toString +"["+ getMissionTranslated(submission, resource) +"])"
								s += " & "
								s += "(P<"+ m.value2.toString +"["+ getMissionTranslated(submission, resource) +"])"
							}
							
						}
					}
				}
				
				// if reward --done 
				else if (m.reward!==null){ 
					switch m{
						// --done
						Maximize:{
							if (m.type=="maximize"){
								s += "R{\""+m.measure+"\"}max=?["+ getMissionTranslated(submission, resource) +"]"
							}
							else if (m.type=="minimize"){
								s += minimizeReward(m, resource)
								
							}
						}
						// --done
						AtMost:{
							var sign =""
							if (m.type=="at most"){
								sign = "<="
							}
							else if (m.type=="less than"){
								sign = "<"
							}
							else if (m.type=="at least"){
								sign = ">="
							}
							else if (m.type=="greater than"){
								sign = ">"
							}
							
							if (m.type=="exactly"){
								s += "("+ rewardSign(s, ">=", m.measure, m.value, submission, resource) +")"
								s += " & "
								s += "("+ rewardSign(s, "<=", m.measure, m.value, submission, resource) +")"
							}
							else{
								s+=	rewardSign(s, sign, m.measure, m.value, submission, resource)
							}
							
						}
						// --done
						Within:{
							if (m.type=="within"){
								s += "("+ rewardSign(s, ">=", m.measure, m.value1, submission, resource) +")"
								s += " & "
								s += "("+ rewardSign(s, "<=", m.measure, m.value2, submission, resource) +")"
							}
							else if (m.type=="strictly within"){
								s += "("+ rewardSign(s, ">", m.measure, m.value1, submission, resource) +")"
								s += " & "
								s += "("+ rewardSign(s, "<", m.measure, m.value2, submission, resource) +")"
							}
							
						}
					}					
					
					
				} 
			
			}
			
			 
			//-- *Composite Patterns
			CompositePatterns:{
				var m = miss
				// -- done
				switch m{
					Conservation:{
						s+= minimizeReward(m, resource)
					}
					Preservation:{
						
						s += rewardBetween_v1v2(m, resource)
					}
					Pause:{
						var submission = m.missions
						var m2 = m.value + 1 // next time step
						
						s += "(G [0,"+m.value.toString+"] "
						s += "!("
						s += getMissionTranslated(submission, resource)
						s += ") ) & ( "
						s += "F["+ m2.toString +","+ m2.toString +"])"
					}
					Timeout:{
						var submission = m.missions
						m.value
						// NOT WORKING ************
						s+= "G<=" + m.value.toString
						s+= " !"+ getMissionTranslated(submission, resource)
						s+= "Timeout: Translation not available." // (NOT WORKING Translation).
					}
					Repeat:{
						var submission = m.missions
						var m0 = m.value - 1 // last time step
						
						s+= "("
						s += getMissionTranslated(submission,resource)
						s+= ") & ("
						s+= "G("
						s+= "(" + getMissionTranslated(submission,resource)+")"
						s+= "=>(G[1,"+ m0.toString +"] (!(" +
							getMissionTranslated(submission,resource)
							+")) & (F["+m.value + "," + m.value+ "] ("
							+ getMissionTranslated(submission,resource)
							+") ) )"
						s+="))"
					}
					End:{
						var submission = m.missions
						m.value
						s+= "G<" + m.value.toString + " ("
						s+= "("+getMissionTranslated(submission,resource)+")"
						s+= " & G>"+ m.value.toString + "!("+ getMissionTranslated(submission,resource) +")"
						s+= ")"
					}
					
					Proportional:{
						//var miss1 = m.mission1
						//var miss2 = m.mission2
						//m.value
						s+= "Proportional: No translation available."
					}
					Execute:{
						m.robots
						m.setOfActions
						for (a: m.setOfActions){
							s+= "(F \""+m.robots.name + a.name + "\") & "
						}
						s = s.substring(0, s.length() - 3);
						//s= "NA (NOT AVAILABLE)"
					}
					Accrue:{
						var submission = m.missions
						m.robots
						m.measure
						s = "Rmax=?["+ getMissionTranslated(submission, resource) +"]"
					}
					ReliabilityConfidence:{
						var submission = m.missions
						if (m.type1=='with reliability'){
							if(m.type2=='greater than'){
								s+=	rewardSign(s, '>', m.measure, m.value, submission, resource)
							}
							else if(m.type2=='less than'){
								s+=	rewardSign(s, '<', m.measure, m.value, submission, resource)
							} 
						}
						else if (m.type1=='with confidence'){
							if(m.type2=='greater than'){
								s+="With confidence: No translation available."// for L
							}
							else if(m.type2=='less than'){
								s+="With confidence: No translation available."// for L
							}
						}
						
					}
					Equidistance:{
						s+= "Equidistance: Translation not available."
					}
					Trail:{
						s+= "Trail: Translation not available"
					}
				}
			}
		}
		return s // return string
	}
	
	
	/** Constraints:
	 * (a) prohibit nested probabilities, (b) accept only LTL
	 * properties for the reward and probability operators, and 
	 * (c) prohibit the definition of specifications that lead to
	 * the conjunction of quantitative and non-quantitative PRISM
	 * formulae since such formulae can not be processed by PRISM.
	 */
	def static String checkFormulae(String s){
		var checked_s = s
		
		//Replace "" for "
		if (s.contains("\"\"")){
			 checked_s = checked_s.replaceAll("\"\"", "\"");
		}
		//Reward inside a parenthesis means it is inside a R or P structure P...(R...), or part of a logic boolean formulae (e.g.: (R...)&(...) ) 
		if (s.contains("(R")){
			checked_s = "WARNING. Translation into PRISM not supported."
			checked_s += "\n  				--Feedback: Reward found inside inside parenthesis-- "
			checked_s += "\n  				--Formulae: "+s
			return checked_s
		}
		//Prob. inside a parenthesis means it is inside a R or P structure P...(P...), or part of a logic boolean formulae (e.g.: (P...)&(...) )
		else if (s.contains("(P")){
			checked_s = "WARNING. Translation into PRISM not supported."
			checked_s += "\n  				--Feedback: Probability found inside parenthesis-- "
			checked_s += "\n  				--Formulae: "+s
			return checked_s
		}
		//Possible error using (G[
		else if (s.contains("(G[")){
			checked_s = "WARNING. Translation into PRISM not supported."
			checked_s += "\n  				--Feedback: G bounded [...] found inside parenthesis-- "
			checked_s += "\n  				--Formulae: "+s
			return checked_s
		}
		
		/**REGEX not working on xtend
		var s2 = "1(R)"
		var rege = "\\("
		checked_s += s2
		if (s2.matches(rege)){
			checked_s += " here: " + rege
		}
		**/
		return checked_s	
	}
	
	
	
	def static rewardSign(String s, String sign, String measure, int value, Missions submission, Resource resource) {
		return "R{\""+measure+"\"}"+ sign + value.toString + " [" + getMissionTranslated(submission, resource) + "]"
	}
	
	/**Minimise reward */
	def static minimizeReward(Conservation m, Resource resource){
		var measure = m.measure
		var submission = m.missions
		return minimizeReward(submission, measure, resource)
	}
	
	def static minimizeReward(Maximize m, Resource resource){
		var measure = m.measure
		var submission = m.mission
		return minimizeReward(submission, measure, resource)
	}
	
	def static minimizeReward(Missions submission, String measure, Resource resource){
		var s=""
		s += "R{\""+measure+"\"}min=?["+ getMissionTranslated(submission, resource) +"]"
		return s
	}
	
	
	/**Reward between */
	def static rewardBetween_v1v2(Preservation m, Resource resource){
			var s=""
			var submission = m.missions
			s += "(R{\""+ m.measure +"\"}>=" + m.value1 + "["  
			s += getMissionTranslated(submission, resource) + "]"
			s+= ") & ("
			s += "R{\""+ m.measure +"\"}<=" + m.value2 + "["  
			s += getMissionTranslated(submission, resource) + "])"
		}
		
	def static getTopMissionTranslated(TopMissions tmiss, Resource resource){
		var id = tmiss.name // mission ID
		var miss = tmiss.mission // mission in top mission
		var s = new String // return string
		// -- get mission translated
		s = getMissionTranslated(miss,resource).replaceAll("\\s","")
		// -- check formulae for consistency
		s = checkFormulae(s)
		// -- add id
		s = id + ": " + s + "\n\n"
		s //return string
	}
	
	
	def static getCondition(Resource resource) {
		//--print translated condition when called in a "pat"
		var s= ""
		s
	}
}
